// This file is autogenerated by the script
// It contains all source and headers files from the project
// without unnecessary `#include` and `#pragma` directives
// Special for Y.Contest



#include <iostream>
#include <cassert>
#include <fstream>

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/Tree.h BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 22.05.2020.
//



enum Direction {Left, Right, Root};
enum Most {Big, Small};

auto inv_dir = [](Direction direction) {
    return direction == Left ? Right : Left;
};

auto most_to_direction = [](Most most) {
    return most == Small ? Left : Right;
};

class Tree {
public:
    struct Node {
        // fields
        int _val;
        int _size = 1;
        Tree::Node* _left = nullptr;
        Tree::Node* _right = nullptr;
        Tree::Node* _parent = nullptr;

        // constructors-destructors
        explicit Node() = default;
        explicit Node(int val);
        Node(Tree::Node* left, int val, Tree::Node* right);


        //std in & out
        friend std::ostream & operator << (std::ostream & out, const Tree::Node & node);
//      std::string to_string(const std::string & s = "") const;
        std::string to_string() const;

        // utilties
        Direction _my_direction();

    public:
        void _rotate(Direction direction);
        void _make_me_parent();
        static Tree::Node* Tree::Node::* _get_child(Direction);
        int get_child_size(Direction direction);
    };

public:

    Tree::Node* _root = nullptr;
    //Tree::Node* min_node = nullptr;
    //Tree::Node* max_node = nullptr;

    void _splay(Tree::Node* node); // node MUST be valid (nullptr not suitable)

//  Tree::Node* _lower_bound(Tree::Node* node, int x); // returns biggest member <= x, if there is no such member, returns nullptr

    Tree::Node* _get_most(Most most); // return pointer to bi..,mggest(Big), smallest(Small) member of tree

    std::pair<Tree*, Tree*> split (int x); // splits tree. After splitting initial tree is NOT VALID any more!

    void merge(Most most, Tree & tree); // Merges a bigger (Big) or smaller(Tree) to existing tree. Old tree is not valid after merge!

    Tree::Node* _get_k(Tree::Node* node, int k); // 1-numeration

    explicit Tree(Tree::Node*);
public:
    Tree::Node* find(int x);
//    Tree::Node* lower_bound(int x);

    int size();
    void add(int x);
    void remove(int x);
    int get_k_min(int k);
    int get_k_max(int k);

    explicit Tree() = default;

    ~Tree();
    void destroy(Tree::Node* node);

    friend std::ostream & operator << (std::ostream & out, const Tree & tree);

    void move_to_start(int i, int j);
};

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/Tree.h ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/construct.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

Tree::Node::Node(int val) : _val(val) {}

Tree::Node::Node(Node *left, int val, Node *right) : _left(left), _val(val), _right(right) {
    _make_me_parent();
}

Tree::Tree(Node * node) : _root(node) {
    if (_root) {
        _root->_parent = nullptr;
    }
}

void Tree::destroy(Tree::Node *node) {
    if (node) {
        destroy(node->_left);
        destroy(node->_right);
        delete node;
    }
}

Tree::~Tree() {
    destroy(_root);
}

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/construct.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/std_in_out.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//


std::ostream & operator<<(std::ostream &out, const Tree::Node & node) {
    std::string s = node.to_string();
    out << s.substr(1, s.length() - 1);
    return out;
}

//std::string Tree::Node::to_string(const std::string & tabs) const {
//    std::string s;
//    s += tabs + std::to_string(_val) + " (sz" + std::to_string(_size) + ")\n";
//    if (_left) {
//        s += tabs + "left\n";
//        s += _left->to_string(tabs + "\t");
//    }
//    if (_right) {
//        s += tabs + "right\n";
//        s += _right->to_string(tabs + "\t");
//    }
//    return s;
//}

std::string Tree::Node::to_string() const {
    std::string ans;
    if (_left)
        ans += _left->to_string();
    ans += " " + std::to_string(_val);
    if (_right)
        ans += _right->to_string();
    return ans;
}

std::ostream & operator<<(std::ostream &out, const Tree & tree) {
    if (tree._root) {
        out << *tree._root;
    }
    else {
        out << "Empty tree (sz 0)\n";
    }
    return out;
}
//----------------------------------------------------------------------------------------------------
// FILE splay-tree/std_in_out.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/splay.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

Tree::Node* Tree::Node::* Tree::Node::_get_child(Direction direction) {
    return direction == Left ? &Tree::Node::_left : &Tree::Node::_right;
}

void Tree::Node::_rotate(Direction direction) {
    auto w_d = inv_dir(direction); // working direction
    assert(this->*_get_child(w_d));
    Node* son = this->*_get_child(w_d);
    Node* grandson = son->*(son->_get_child(inv_dir(w_d)));
    Node* dad = _parent;
    son->*_get_child(inv_dir(w_d)) = this;
    this->*_get_child(w_d) = grandson;
    if (dad) {
        dad->*dad->_get_child(this->_my_direction()) = son;
    }
    _make_me_parent();
    son->_make_me_parent();
    if (dad) {
        dad->_make_me_parent();
    }
    else {
        son->_parent = nullptr;
    }
}

void Tree::_splay(Node *node) {
    assert(node);
    while (node->_parent) {
        if (node->_parent->_left == node) {
            node->_parent->_rotate(Right);
        }
        else {
            node->_parent->_rotate(Left);
        }
    }
    _root = node;
}
//----------------------------------------------------------------------------------------------------
// FILE splay-tree/splay.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/utilitites.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

void Tree::Node::_make_me_parent() {
    _size = 1;
    if (_left){
        _left->_parent = this;
        _size += _left->_size;
    }
    if (_right) {
        _right->_parent = this;
        _size += _right->_size;
    }
}

Direction Tree::Node::_my_direction() {
    if (_parent) {
        return (_parent->_left == this) ? Left : Right;
    }
    else {
        return Root;
    }
}

int Tree::Node::get_child_size(Direction direction) {
    if (this->*_get_child(direction)) {
        return (this->*_get_child(direction))->_size;
    }
    else {
        return 0;
    }
}

int Tree::size() {
    if (_root)
        return _root->_size;
    return 0;
}

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/utilitites.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/find.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

Tree::Node* Tree::find(int x) {
    Node* node = _root;
    return _get_k(node, x);
}

Tree::Node * Tree::_get_most(Most most) {
//    if (_root) {
//        return most == Big ? max_node : min_node;
//    }
    Node* node = _root;
    while (node->*(node->_get_child(most_to_direction(most)))) {
        node = node->*(node->_get_child(most_to_direction(most)));
    }
    return node;
    return nullptr;
}

Tree::Node* Tree::_get_k(Tree::Node *node, int k) {
    assert(node->_size >= k);
    while (k != node->get_child_size(Left) + 1) {
        if (k < node->get_child_size(Left) + 1) {
            node = node->_left;
        }
        else {
            k -= node->get_child_size(Left) + 1;
            node = node->_right;
        }
    }
    _splay(node);
    return node;
}

//int Tree::get_k_min(int k) {
//    k--;
//    assert(_root->_size > k);
//    return _get_k(_root, k);
//}

//int Tree::get_k_max(int k) {
//    return get_k_min(_root->_size - (k - 1));
//}

//Tree::Node * Tree::lower_bound(int x) {
//    if (find(x)) {
//        return find(x);
//    }
//    Node* ans =  _lower_bound(_root, x);
//    if (ans) {
//        _splay(ans);
//    }
//    return ans;
//}

//Tree::Node * Tree::_lower_bound(Node * node, int x) {
//    if (node == nullptr)
//        return nullptr;
//    if (node->_val > x) {
//        return _lower_bound(node->_left, x);
//    }
//    else {
//        Node* ans = _lower_bound(node->_right, x);
//        if (ans) {
//            return ans;
//        }
//        return node;
//    }
//}

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/find.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/basic_operations.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

std::pair<Tree*, Tree*> Tree::split(int x) {
    if (x == 0) {
        return {new Tree(), this};
    }
    Node* splitter = find(x);
    Node* r_child = splitter->_right;
    if (splitter->_right ) {
        splitter->_right->_parent = nullptr;
        splitter->_right = nullptr;
    }
    splitter->_make_me_parent();
    Tree* new_tree = new Tree(r_child);
//    if (new_tree->_root) {
//        new_tree->max_node = max_node;
//        Node * node = new_tree->_root;
//        while (node->_left)
//            node = node->_left;
//        new_tree->min_node = node;
//    }
//    max_node = _root;
    return {this, new_tree};
}

void Tree::merge(Most most, Tree &tree) {
    Node* node = _get_most(most);
    if (node) {
        _splay(node);
        Node* & child = _root->*Tree::Node::_get_child(most_to_direction(most));
        assert(child == nullptr);
        child = tree._root;
        _root->_make_me_parent();
//        if (tree._root) {
//            if (most == Big) {
//                max_node = tree.max_node;
//            }
//            else {
//                min_node = tree.min_node;
//            }
//        }
    }
    else {
        _root = tree._root;
    }
}

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/basic_operations.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE splay-tree/operations.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------
//
// Created by Михаил Лобанов on 25.05.2020.
//

void Tree::move_to_start(int i, int j) {
    if (i == 1)
        return;
    int before = i - 1;
    int amount = j - i + 1;
    auto trs1 = split(before);
    auto trs2 = trs1.second->split(amount);
    trs2.first->merge(Big, *trs1.first);
    trs2.first->merge(Big, *trs2.second);
    _root = trs2.first->_root;
}

void Tree::add(int x) {
    if (!_root) {
        _root = new Node(x);
//        max_node = _root;
//        min_node = _root;
        return;
    }
    Node* max_node = _get_most(Big);
    _splay(max_node);
    max_node->_right = new Node(x);
    max_node->_make_me_parent();
    max_node = max_node->_right;
    max_node->_make_me_parent();
}

void Tree::remove(int x) {
    assert(find(x));
    Node* node = find(x);
    _splay(node);
    Tree* tr1 = new Tree(node->_left);
    Tree* tr2 = new Tree(node->_right);
    tr1->merge(Big, *tr2);
    _root = tr1->_root;
}


//----------------------------------------------------------------------------------------------------
// FILE splay-tree/operations.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE main.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------

using namespace std;
using Nd = Tree::Node;


int main() {
    //ios_base::sync_with_stdio(false);
    //cin.tie(NULL);
    //ifstream fin("../test.txt");
    ifstream fin("g.in");
    ofstream fout("g.out");
    int n, m;
    fin >> n >> m;
    Tree tree;
    for (int i = 0; i < n; ++i) {
        tree.add(i + 1);
    }
    tree.find(n / 2);
    for (int j = 0; j < m; ++j) {
        int x, y;
        fin >> x >> y;
        tree.move_to_start(x, y);
        tree.find(n / 2);
    }
    fout << tree;
    fin.close();
    fout.close();
    return 0;
}

//----------------------------------------------------------------------------------------------------
// FILE main.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

// Generated by the script
