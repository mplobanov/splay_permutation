//
// Created by Михаил Лобанов on 27.05.2020.
//
// This file is autogenerated by the script
// It contains all source and headers files from the project
// without unnecessary `#include` and `#pragma` directives
// Special for Y.Contest



#include <iostream>
#include <vector>
#include <functional>

//----------------------------------------------------------------------------------------------------
// FILE Tree.h BEGINS HERE
//----------------------------------------------------------------------------------------------------

#ifndef NEXTPERMUTATIONONSUBSEGMENT_TREE_H
#define NEXTPERMUTATIONONSUBSEGMENT_TREE_H


class Tree {
private:
    struct Node {
        Node* parent = nullptr;
        Node* left = nullptr;
        Node* right = nullptr;
        long long val = 0;
        long long sum = 0;
        int assign = 0;
        bool assigned = false;
        long long delta = 0;
        int increasingSuffix = 0;
        int decreasingSuffix = 0;
        int increasingPrefix = 0;
        int decreasingPrefix = 0;
        bool reversed = false;
        int size = 0;
        int leftmostValue = 0;
        int rightmostValue = 0;

        explicit Node() = default;
        explicit Node(long long val);
        explicit Node(long long val, Node* left, Node* right);
    };

    Node* _root = nullptr;
    bool _doDestruct = true;

    static Node* _merge(Node* l, Node* r);
    static std::pair<Node*, Node*> _split(Node* node, int pos);
    static std::pair<Node*, long long> _last_bigger(Node* node, int x, int ind = 0);
    static std::pair<Node*, long long> _last_smaller(Node* node, int x, int ind = 0);
    static std::pair<Node*, long long> _last_smaller_bigger(Node* node, int x, int ind = 0, bool bigger = true);
    static void _set_parent(Node* child, Node* parent);
    static void _keep_parent(Node* v);
    static void _rotate(Node* parent, Node* child);
    static void _push(Node* v);
    static void _update(Node* v);
    static void _update_leftmost_value(Node* v);
    static void _update_rightmost_value(Node* v);
    static void _update(Node* v, int Tree::Node::* field, bool increasing, bool suffix);
    static Node* _splay(Node* v);
    static Node* _find(Node* v, int ind);
    static Node* _insert(Node* v, int pos, int x);
    static void _print(Node* v, std::ostream& out);
    static std::vector<long long> _get_values(Node* v);
    static void _destruct(Node* v);
    void _next_prev_permutation(int l, int r, bool next);
    long long _execute_query(int l, int r, const std::function<void(Node*&, long long& res)>& executor);
    static void _node_assign(Node* node, int x);
    static void _node_add(Node* node, int delta);
    static long long _node_erase(Node*& node);
    static void node_next_prev_permutation(Node*& node, bool next);
    std::tuple<Tree::Node*, Tree::Node*, Tree::Node*> _get_subsegment(int l, int r);

    template <typename T>
    static T _getter(Tree::Node* v, T Tree::Node::* member);
public:
    explicit Tree() = default;
    explicit Tree(std::vector<int>& initialValues);
    explicit Tree(Node* node, bool doDestruct) : _root(node), _doDestruct(doDestruct) {}
    ~Tree();

    long long get_sum(int l, int r);
    void insert(int pos, int x);
    long long erase(int pos);
    void assign(int l, int r, int x);
    void add(int l, int r, int delta);
    void next_permutation(int l, int r);
    void prev_permutation(int l, int r);
    void print(std::ostream& out = std::cout);
    std::vector<long long> get_values();
};

#endif //NEXTPERMUTATIONONSUBSEGMENT_TREE_H

//----------------------------------------------------------------------------------------------------
// FILE Tree.h ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE Tree.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------

Tree::Tree(std::vector<int>& initialValues) {
    for (size_t i = 0; i < initialValues.size(); ++i) {
        insert(i, initialValues[i]);
    }
}

std::tuple<Tree::Node*, Tree::Node*, Tree::Node*> Tree::_get_subsegment(int l, int r) {
    auto tmp1 = _split(_root, r);
    auto tmp2 = _split(tmp1.first, static_cast<int>(l) - 1);
    return {tmp2.first, tmp2.second, tmp1.second};
}

long long Tree::_execute_query(int l, int r, const std::function<void(Node*&, long long& res)>& executor) {
    auto [part1, part2, part3] = _get_subsegment(l, r);
    long long res = 0;
    executor(part2, res);
    _root = _merge(_merge(part1, part2), part3);
    return res;
}

long long Tree::get_sum(int l, int r) {
    return _execute_query(l, r, [](Node*& node, long long& res) { res = _getter(node, &Node::sum); });
}

void Tree::insert(int pos, int x) {
    _root = _insert(_root, pos, x);
}

Tree::Node* Tree::_insert(Tree::Node* v, int pos, int x) {
    auto [left, right] = _split(v, static_cast<int>(pos) - 1);
    Node* new_node = new Node(x);
    return _merge(_merge(left, new_node), right);
}

long long Tree::_node_erase(Tree::Node*& node) {
    auto res = _getter(node, &Node::val);
    node = nullptr;
    return res;
}

long long Tree::erase(int pos) {
    return _execute_query(pos, pos, [](Node*& node, long long& res) { res = _node_erase(node); });
}

void Tree::_node_assign(Node* node, int x) {
    node->assign = x;
    node->assigned = true;
    node->delta = 0;
    _push(node);
}

void Tree::assign(int l, int r, int x) {
    _execute_query(l , r, [x](Node*& node, auto) { _node_assign(node, x); });
}

void Tree::_node_add(Node* node, int delta) {
    node->delta += delta;
    _push(node);
}

void Tree::add(int l, int r, int delta) {
    _execute_query(l , r, [delta](Node*& node, auto) { _node_add(node, delta); });
}

void Tree::node_next_prev_permutation(Node*& node, bool next) {
    Node* tree = node;
    _push(tree);

    int prefixSize = tree->size - (next ? tree->decreasingSuffix : tree->increasingSuffix) - 1;
    auto tmp = _split(tree, prefixSize);
    auto leftTree = Tree(tmp.first, false);
    auto rightTree = Tree(tmp.second, false);
    if (tmp.first) {
        _push(leftTree._root);

        std::pair<Tree::Node*, long long> swapped;
        if (next) {
            swapped = _last_bigger(rightTree._root, leftTree._root->rightmostValue);
        } else {
            swapped = _last_smaller(rightTree._root, leftTree._root->rightmostValue);
        }
        auto [swapElement, swapElementInd] = swapped;

        long long swapElement1 = leftTree.erase(prefixSize);
        _push(swapElement);
        leftTree.insert(prefixSize, swapElement->val);
        rightTree.erase(swapElementInd);
        rightTree.insert(swapElementInd, swapElement1);
    }
    rightTree._root->reversed = !rightTree._root->reversed;
    _push(rightTree._root);
    node = _merge(leftTree._root, rightTree._root);
}

void Tree::_next_prev_permutation(int l, int r, bool next) {
    _execute_query(l , r, [next](Node*& node, auto) { node_next_prev_permutation(node, next); });
}

void Tree::next_permutation(int l, int r) {
    _next_prev_permutation(l, r, true);
}

void Tree::prev_permutation(int l, int r) {
    _next_prev_permutation(l, r, false);
}

void Tree::_set_parent(Tree::Node* child, Tree::Node* parent) {
    if (child) {
        child->parent = parent;
    }
}

void Tree::_keep_parent(Tree::Node* v) {
    _set_parent(v->left, v);
    _set_parent(v->right, v);
}

void Tree::_rotate(Tree::Node *parent, Tree::Node *child) {
    Node* greatParent = parent->parent;
    _push(greatParent);
    _push(parent);
    _push(child);
    if (greatParent) {
        if (greatParent->left == parent) {
            greatParent->left = child;
        } else {
            greatParent->right = child;
        }
    }
    if (parent->left == child) {
        parent->left = child->right;
        _update(parent);
        child->right = parent;
        _update(child);
    } else {
        parent->right = child->left;
        _update(parent);
        child->left = parent;
        _update(child);
    }
    _keep_parent(child);
    _keep_parent(parent);
    child->parent = greatParent;
}

void Tree::_update(Node* v, int Tree::Node::* field, bool increasing, bool suffix) {
    _push(v);
    Node* son = (suffix ? v->right : v->left);
    Node* anotherSon = (suffix ? v->left : v->right);
    v->*field = _getter(son, field);
    if (_getter(son, field) == _getter(son, &Node::size)) {
        if (son) {
            auto val = (suffix ? son->leftmostValue : son->rightmostValue);
            if (!((increasing ^ suffix) ? (val <= v->val) : (val >= v->val))) {
                return;
            }
        }
        ++(v->*field);
        if (!anotherSon) {
            return;
        }
        auto val1 = (suffix ? anotherSon->rightmostValue : anotherSon->leftmostValue);
        if ((increasing ^ suffix) ? (val1 >= v->val) : (val1 <= v->val)) {
            v->*field += _getter(anotherSon, field);
        }
    }
}

void Tree::_update_leftmost_value(Tree::Node *v) {
    if (v->left) {
        v->leftmostValue = v->left->leftmostValue;
    } else {
        v->leftmostValue = v->val;
    }
}

void Tree::_update_rightmost_value(Tree::Node *v) {
    if (v->right) {
        v->rightmostValue = v->right->rightmostValue;
    } else {
        v->rightmostValue = v->val;
    }
}

void Tree::_update(Tree::Node *v) {
    if (!v) {
        return;
    }
    _push(v);
    _push(v->left);
    _push(v->right);
    v->sum = _getter(v->left, &Node::sum) + _getter(v->right, &Node::sum) + v->val;
    _update(v, &Node::decreasingSuffix, false, true);
    _update(v, &Node::increasingSuffix, true, true);
    _update(v, &Node::decreasingPrefix, false, false);
    _update(v, &Node::increasingPrefix, true, false);
    v->size = _getter(v->left, &Node::size) + _getter(v->right, &Node::size) + 1;
    _update_leftmost_value(v);
    _update_rightmost_value(v);
}

void Tree::_push(Tree::Node* v) {
    if (!v) {
        return;
    }
    if (v->reversed) {
        std::swap(v->left, v->right);
        std::swap(v->increasingSuffix, v->decreasingPrefix);
        std::swap(v->decreasingSuffix, v->increasingPrefix);
        std::swap(v->leftmostValue, v->rightmostValue);
        if (v->left) {
            v->left->reversed = !v->left->reversed;
        }
        if (v->right) {
            v->right->reversed = !v->right->reversed;
        }
        v->reversed = false;
    }
    if (v->assigned) {
        v->val = v->assign;
        v->sum = v->assign * v->size;
        v->increasingSuffix = v->size;
        v->decreasingSuffix = v->size;
        v->increasingPrefix = v->size;
        v->decreasingPrefix = v->size;
        v->leftmostValue = v->assign;
        v->rightmostValue = v->assign;
        if (v->left) {
            v->left->assigned = true;
            v->left->assign = v->assign;
            v->left->delta = 0;
        }
        if (v->right) {
            v->right->assigned = true;
            v->right->assign = v->assign;
            v->right->delta = 0;
        }
        v->assigned = false;
    }
    if (v->delta != 0) {
        v->val += v->delta;
        v->sum += v->delta * v->size;
        v->leftmostValue += v->delta;
        v->rightmostValue += v->delta;
        if (v->left) {
            v->left->delta += v->delta;
        }
        if (v->right) {
            v->right->delta += v->delta;
        }
        v->delta = 0;
    }
}

template <typename T>
T Tree::_getter(Tree::Node* v, T Tree::Node::* member) {
    if (!v) {
        return 0;
    }
    return v->*member;
}

Tree::Node *Tree::_splay(Tree::Node *v) {
    if (!v->parent) {
        return v;
    }
    Node* parent = v->parent;
    Node* greatParent = parent->parent;
    _push(greatParent);
    _push(parent);
    _push(v);
    if (greatParent) {
        if ((greatParent->left == parent) == (parent->left == v)) {
            _rotate(greatParent, parent);
            _rotate(parent, v);
        } else {
            _rotate(parent, v);
            _rotate(greatParent, v);
        }
        return _splay(v);
    } else {
        _rotate(parent, v);
        return v;
    }
}

Tree::Node *Tree::_find(Tree::Node *v, int ind){
    if (!v) {
        return nullptr;
    }
    _push(v);
    int cur_ind = _getter(v->left, &Node::size);
    Node* res;
    if (cur_ind == ind) {
        res = _splay(v);
    } else if (ind < cur_ind && v->left) {
        res = _find(v->left, ind);
    } else if (ind > cur_ind && v->right) {
        res = _find(v->right, ind - cur_ind - 1);
    } else {
        res = _splay(v);
    }
    return res;
}

std::pair<Tree::Node*, Tree::Node*> Tree::_split(Tree::Node* node, int pos) {
    if (!node) {
        return {nullptr, nullptr};
    }
    if (pos < 0) {
        return {nullptr, node};
    }
    _push(node);
    if (pos >= node->size) {
        return {node, nullptr};
    }
    node = _find(node, pos);
    if (node->right) {
        _set_parent(node->right, nullptr);
        Node* right = node->right;
        node->right = nullptr;
        _update(node);
        return {node, right};
    } else {
        return {node, nullptr};
    }
}

Tree::Node* Tree::_merge(Tree::Node* l, Tree::Node* r) {
    if (!l) {
        return r;
    }
    if (!r) {
        return l;
    }
    _push(r);
    r = _find(r, 0);
    r->left = l;
    _update(r);
    l->parent = r;
    return r;
}

std::pair<Tree::Node*, long long int> Tree::_last_smaller_bigger(Tree::Node* node, int x, int ind, bool bigger) {
    _push(node);
    std::pair<Tree::Node*, long long> res;
    if ((bigger && node->val > x) || (!bigger && node->val < x)) {
        _push(node->right);
        _push(node->left);
        if (node->right &&
            ((bigger && node->right->leftmostValue > x) || (!bigger && node->right->leftmostValue < x))) {
            res = _last_smaller_bigger(node->right, x, ind + _getter(node->left, &Node::size) + 1, bigger);
        } else {
            res = {node, ind + _getter(node->left, &Node::size)};
        }
    } else {
        // bigger exists
        res = _last_smaller_bigger(node->left, x, ind, bigger);
    }
    _update(node);
    return res;
}

// values should be decreasing
// bigger exists
std::pair<Tree::Node*, long long> Tree::_last_bigger(Tree::Node* node, int x, int ind) {
    return _last_smaller_bigger(node, x, ind, true);
}

// values should be increasing
// smaller exists
std::pair<Tree::Node*, long long> Tree::_last_smaller(Tree::Node* node, int x, int ind) {
    return _last_smaller_bigger(node, x, ind, false);
}

void Tree::_print(Tree::Node* v, std::ostream& out) {
    if (!v) {
        return;
    }
    _push(v);
    if (v->left) {
        _print(v->left, out);
    }
    out << v->val << " ";
    if (v->right) {
        _print(v->right, out);
    }
    _update(v);
}

void Tree::print(std::ostream& out) {
    _print(_root, out);
}

std::vector<long long> Tree::get_values() {
    return _get_values(_root);
}

std::vector<long long> Tree::_get_values(Tree::Node *v) {
    std::vector<long long> res;
    _push(v);
    if (v->left) {
        std::vector<long long> tmp = _get_values(v->left);
        std::copy(tmp.begin(), tmp.end(), std::back_inserter(res));
    }
    res.push_back(v->val);
    if (v->right) {
        std::vector<long long> tmp = _get_values(v->right);
        std::copy(tmp.begin(), tmp.end(), std::back_inserter(res));
    }
    _update(v);
    return res;
}

Tree::~Tree() {
    if (_doDestruct) {
        _destruct(_root);
    }
}

void Tree::_destruct(Tree::Node *v) {
    if (!v) {
        return;
    }
    _destruct(v->left);
    _destruct(v->right);
    delete v;
}


Tree::Node::Node(long long val) {
    this->val = val;
    sum = val;
    size = 1;
    increasingSuffix = 1;
    decreasingSuffix = 1;
    increasingPrefix = 1;
    decreasingPrefix = 1;
    leftmostValue = val;
    rightmostValue = val;
}

Tree::Node::Node(long long val, Tree::Node *left, Tree::Node *right) : Node(val) {
    this->left = left;
    this->right = right;
}

//----------------------------------------------------------------------------------------------------
// FILE Tree.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE Solver.h BEGINS HERE
//----------------------------------------------------------------------------------------------------

#ifndef NEXTPERMUTATIONONSUBSEGMENT_SOLVER_H
#define NEXTPERMUTATIONONSUBSEGMENT_SOLVER_H



class Solver {
private:
    std::istream& _in = std::cin;
    std::ostream& _out = std::cout;
public:
    Solver() = default;
    explicit Solver(std::istream& in, std::ostream& out) : _in(in), _out(out) {}

    void solve();
};


#endif //NEXTPERMUTATIONONSUBSEGMENT_SOLVER_H

//----------------------------------------------------------------------------------------------------
// FILE Solver.h ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE Solver.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------

void Solver::solve() {
//    size_t n;
//    _in >> n;
//    std::vector<int> initialValues(n);
//    for (int& it : initialValues) {
//        _in >> it;
//    }
//    Tree tree(initialValues);
//    size_t q;
//    _in >> q;
//    for (size_t i = 0; i < q; ++i) {
//        size_t type;
//        _in >> type;
//        if (type == 1) {
//            size_t l, r;
//            _in >> l >> r;
//            _out << tree.get_sum(l, r) << "\n";
//        } else if (type == 2) {
//            int x;
//            size_t pos;
//            _in >> x >> pos;
//            tree.insert(pos, x);
//        } else if (type == 3) {
//            size_t pos;
//            _in >> pos;
//            tree.erase(pos);
//        } else if (type == 4 || type == 5) {
//            int x;
//            size_t l, r;
//            _in >> x >> l >> r;
//            if (type == 4) {
//                tree.assign(l, r, x);
//            } else {
//                tree.add(l, r, x);
//            }
//        } else {
//            size_t l, r;
//            _in >> l >> r;
//            if (type == 6) {
//                tree.next_permutation(l, r);
//            } else {
//                tree.prev_permutation(l, r);
//            }
//        }
//    }
    Tree tree;
    for(int i = 0; i < 100004; ++i) {
        tree.insert(i, i);
    }
    for (int i = 0; i < 100000; ++i) {
        tree.erase(0);
    }
    tree.print();
}

//----------------------------------------------------------------------------------------------------
// FILE Solver.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------
// FILE main.cpp BEGINS HERE
//----------------------------------------------------------------------------------------------------

int main() {
    Solver solver;
    solver.solve();
}
//----------------------------------------------------------------------------------------------------
// FILE main.cpp ENDS HERE
//----------------------------------------------------------------------------------------------------

// Generated by the script


